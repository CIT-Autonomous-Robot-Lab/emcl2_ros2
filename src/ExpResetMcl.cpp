//SPDX-FileCopyrightText: 2022 Ryuichi Ueda ryuichiueda@gmail.com
//SPDX-License-Identifier: LGPL-3.0-or-later

#include "emcl2/ExpResetMcl.h"

#include <rclcpp/rclcpp.hpp>

#include <stdlib.h>

#include <cmath>
#include <iostream>

namespace emcl2
{
ExpResetMcl::ExpResetMcl(
  const Pose & p, int num, const Scan & scan, const std::shared_ptr<OdomModel> & odom_model,
  const std::shared_ptr<LikelihoodFieldMap> & map, double alpha_th, double open_space_th,
  double expansion_radius_position, double expansion_radius_orientation)
: Mcl::Mcl(p, num, scan, odom_model, map),
  alpha_threshold_(alpha_th),
  open_space_threshold_(open_space_th),
  expansion_radius_position_(expansion_radius_position),
  expansion_radius_orientation_(expansion_radius_orientation)
{
}

ExpResetMcl::~ExpResetMcl() {}

void ExpResetMcl::sensorUpdate(double lidar_x, double lidar_y, double lidar_t, bool inv)
{
	if (processed_seq_ == scan_.seq_) return;

	Scan scan;
	int seq = -1;
	while (seq != scan_.seq_) {  //trying to copy the latest scan before next
		seq = scan_.seq_;
		scan = scan_;
	}

	scan.lidar_pose_x_ = lidar_x;
	scan.lidar_pose_y_ = lidar_y;
	scan.lidar_pose_yaw_ = lidar_t;

	int i = 0;
	if (!inv) {
		for ([[maybe_unused]] auto & _ : scan.ranges_)
			scan.directions_16bit_.push_back(Pose::get16bitRepresentation(
			  scan.angle_min_ + (i++) * scan.angle_increment_));
	} else {
		for ([[maybe_unused]] auto & _ : scan.ranges_)
			scan.directions_16bit_.push_back(Pose::get16bitRepresentation(
			  scan.angle_max_ - (i++) * scan.angle_increment_));
	}

	double valid_pct = 0.0;
	int valid_beams = scan.countValidBeams(&valid_pct);
	if (valid_beams == 0) return;

	for (auto & p : particles_) p.w_ *= p.likelihood(map_.get(), scan);

	alpha_ = normalizeBelief() / valid_beams;
	//alpha_ = nonPenetrationRate( particles_.size() / 20, map_.get(), scan); //new version
	RCLCPP_INFO(rclcpp::get_logger("emcl2_node"), "ALPHA: %f / %f", alpha_, alpha_threshold_);
	if (alpha_ < alpha_threshold_ and valid_pct > open_space_threshold_) {
		RCLCPP_INFO(rclcpp::get_logger("emcl2_node"), "RESET");
		expansionReset();
		for (auto & p : particles_) p.w_ *= p.likelihood(map_.get(), scan);
	}

	if (normalizeBelief() > 0.000001)
		resampling();
	else
		resetWeight();

	processed_seq_ = scan_.seq_;
}

void ExpResetMcl::expansionReset(void)
{
	for (auto & p : particles_) {
		double length = 2 * ((double)rand() / RAND_MAX - 0.5) * expansion_radius_position_;
		double direction = 2 * ((double)rand() / RAND_MAX - 0.5) * M_PI;

		p.p_.x_ += length * cos(direction);
		p.p_.y_ += length * sin(direction);
		p.p_.t_ += 2 * ((double)rand() / RAND_MAX - 0.5) * expansion_radius_orientation_;
		p.w_ = 1.0 / particles_.size();
	}
}

}  // namespace emcl2
